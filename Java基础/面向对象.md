### 类和对象

#### 1.1 对象

- 对象的理解：一切皆为对象，对象一定是具体的，既可以是实物，也可以是一个概念

- 对象几大特性：封装、继承、多态、抽象、唯一性

- 对象的组成

  - 属性：成员变量，对象具有基本特征 ---》名词
  - 方法：成员方法，动作或行为，功能 ---》动词
  - 对象是一个整体，不能分割，否则会破坏它的特征和行为

- 封装：是一种信息隐藏技术，把属性和方法包含在对象内部，对外隐藏具体细节，以对象的形式整体展现；需要通过对象来访问属性和方法

- 面向过程 vs 面向对象

  1. 面向过程：以计算机可以理解的方式去编程；核心：数据结构 + 算法 ===》函数  （计算机主导）
  2. 面向对象：以人类可以理解的方式去编程（实际问题）；核心：对象（属性 + 方法） ===》对象.方法(人类主导)

- 面向对象分类

  1. OOP 面向对象编程 ---》写代码

  2. OOA 面向对象分析 ---》需求分析

  3. OOD 面向对象设计 ---》软件设计

  4. OOT 面向对象测试 ---》软件测试

     开发软件和产品，需要有面向对象的思想，思维方式

#### 1.2 类

- 类：是抽象的，针对同种对象的归纳总结；Java中类是程序的基本单元

  - 分类；类是对象的类型；类是对象的模板；类是对象的总结，包含对象所具有的所有属性和方法、

  - Java的8种基本类型，满足不了实际业务需求；自定义一些复杂的类型（类，复合数据类型），按照类型把数据保存到内存中

  - 如何去定义类

    ```java
    public class 类名{
        //属性
        
        //方法
    }
    ```

    * 类：是一个文本文件，是静态的

     * 对象：在内存中存活的，有具体地址，占用内存空间；是动态的

     * 创建对象：

        * 类名 对象名 = new 类名();

     * 使用对象

        * 使用属性：

           * 赋值/写：对象名.属性名 = 属性值;   cat.color = "black";
           * 获取/读：数据类型 变量名 = 对象名.属性名;  String color = cat.color;

        * 使用方法：

          对象.方法()   --->无参方法       cat.eat();

          对象.方法(实参列表)  --->有参方法         cat.eat("鱼");

- 面向对象的优点：

  - 与人类思维习惯一致
  - 信息隐藏：提高程序的可维护性和安全性，封装实现了模块化和信息隐藏
  - 提高了程序的可重用性：一个类可以创建多个对象实例

- 创建对象不一定非要通过new关键字，比如也可以通过反射的方式， 

- 对象中并非必须有属性和方法，可以只有属性，也可以只有方法

### 类的无参和带参方法

#### 2.1 类的方法

- 方法：一般在类内部，方法不能嵌套；方法是程序处理业务的最小单元；

  - 目的：为了完成某项功能代码的集合
  - 功能方法：一般情况下不包括输入输出，具有单一功能

- 分类：

  1. 成员方法
  2. 构造方法
  3. 静态方法
  4. 主方法：一个类中只能有一个

- 定义：

  - 无参方法

    ```java
    权限修饰符  返回值类型  方法名() {
    //方法体
    }
    ```

  - 有参方法

    ```java
    权限修饰符  返回值类型  方法名(参数列表) {
    	//方法体
    }
    ```

    参数列表：参数的个数，参数的类型，参数的顺序

    返回值类型：有返回值，该返回值对应的类型；没有返回值，关键字 void

  - 方法定义部分的参数，一律称为形式参数，简称形参；形参有类型
  - 方法调用部分的参数，一律称为实际参数，简称实参；实参是具体数据，数据的类型与形参保持一致 

#### 2.2 变量的作用域

- 成员变量：在类中定义的变量
  - 如果类中没有给它赋初始值，Java会给它一个默认值；基本类型0，引用类型null
- 局部变量：
  - Java不会给局部变量赋初始值，必须定义赋值后再使用
- 在同一个方法中，不允许有同名的局部变量，在不同方法中，可以有同名的局部变量
- 局部变量可以和成员变量同名，并且在使用时，局部变量具有更高的优先级

#### 2.3 类方法与实例方法区别 
- 静态方法在程序开始时生成内存，实例方法在程序运行中生成内存，所以静态方法可以直接调用。
- 实例方法要先成生实例，通过实例调用方法，静态速度很快，但是多了会占内存。
- 静态内存是连续的，因为是在程序开始时就生成了，而实例申请的是离散的空间，所以当然没有静态方法快，而且静态内存是有限制的，太多了程序会启动不了。
- 类方法常驻内存，实例方法不是，所以类方法效率高但占内存。
- 类方法在堆上分配内存，实例方法在堆栈上。
- 实例方法需要先创建实例才可以调用，比较麻烦，类方法不用，比较简单。
- 类方法，也称静态方法，指的是用static关键字修饰的方法。此方法属类本身的方法，不属于类的某一个实例（对象）。
- 类方法中不可直接使用实例变量。其调用方式有三种：可直接调用、类名.方法名、对象名.方法名。
- 实例方法指的是不用static关键字修饰的方法。每个实例对象都有自身的实例方法，互相独立，不共享一个。其调用方式只能是对象名+方法名。
- 使用场景
  - 如果需要访问或者修改某个实例的成员变量时，将该方法定义成实例方法。类方法正好相反，它不需要访问或者修改某个实例的成员变量。
  - 类方法一般用于实现一些工具方法，比如对某个对象进行扩展，或者实现单例。
  - 事实上如果一个方法与他所在类型的实例无关，那么它就应该是静态的，决不会有人把它写成实例方法。所以所有的实例方法都与实例有关，既然与实例有关，那么创建实例就是必然的步骤，没有麻烦简单一说。实际上上你可以把所有的实例方法都写成静态的，将实例作为参数传入即可。

### 对象和封装

#### 3.1重载

- 重载：Overload，方法名相同，参数列表不同，与返回值类型无关
  - 特征：
    1. 在同一类中（同一作用域内）
    2. 方法名相同
    3. 参数列表不同（参数的类型，参数的个数，参数顺序）
    4. 与返回值类型无关
  - 作用：重复使用方法名；某一功能提供一套方法，

#### 3.2static修饰符

- static：静态的，类专属的，可以共享数据

  - 使用：

    1. 一般情况下不能修饰类，特殊情况：内部静态类

    2. 可以修饰变量

    3. 可以修饰方法

    4. 静态变量：静态方式是类专属的，推荐使用类来访问

       ```类名.
       类名.静态变量           类名.静态方法(参数列表)
       ```

    5. 静态的可以互相直接访问（类内部），main方法也是静态的，但是不能被其它访问

    6. 可以通过对象访问静态变量/方法，实际开发中，强烈不推荐使用（禁止使用）

    7. 项目经验：工具类中的方法，必须使用静态的；需要共享数据，需要使用静态变量

    注意：

    1. 静态的（静态变量、静态方法）可以互相访问，非静态（成员变量、成员方法）的也可以互相访问
    2. 非静态的可以直接访问静态的
    3. 静态的不可以直接访问非静态的，如果要访问，必须通过对象

  - 静态块：

    1. 只会初始化一次，先于对象执行，不能被其它调用

    2. 一般用来初始化静态变量，调用静态方法

    3. 不能直接使用属性和普通方法

       可以通过创建对象来调用对象的属性和方法（不推荐使用）

  - 普通块：

    1. 只会初始化一次，先于对象执行，不能被其它调用
    2. 一般用来初始化成员变量，调用成员方法
    3. 可以调用静态变量/静态方法

#### 3.3包

- 包：相当于文件夹/目录，可以嵌套，作用是区分和管理类

- 命名规范：

  1. 全小写
  2. 域名倒写
  3. 不能数字开头，不能是关键字

- import 导入包：使用其它的类，需要先导入其完整路径（包名 + 类名）

  注意：

  1. jdk中，java,lang 包是默认导入的
  2. 导入包，有两种形式
     1. 通过完整路径，用一个导入一个（推荐）
     2. 通过 * ，导入某包下所有的类（不推荐）
  3. 静态导入

- 完整的类结构：

  ```java
  package …… //类中的第一行代码
  
  import …… //第二块，导入其它的包
  
  public class 类名{//类的定义
      //属性定义
  	public int id;
      //方法定义
      public void getId(){
          return id;
      }
      //主方法
      public static void main(String[] args){
          
      }
  }
  ```

#### 3.4构造方法

- 构造方法：

  1. 定义：与类名相同，没有返回值类型，参数可有可无

     1. 

  2. 注意

     1. 每个类，不写构造方法，系统提供一个默认无参的构造方法

     2. 每个类，写了构造方法，无论是否有参无参，系统不再提供默认的无参构造方法

        写构造方法，必须要写一个无参的构造方法

     3. 构造方法可以重载

     4. 不能通过对象来调用构造方法

     5. 构造方法之间可以互相调用

        通过this() 调用，必须是构造方法中的第一条语句

  3. 作用：创建对象同时初始化属性数据

- 关键字 this  当前对象

  - 2种用法····
    - 属性和方法之间互相调用  this.属性  /  this.方法()
    - 构造方法之间互相调用，不能省略  必须是第一条语句   this()  /  this(参数列表)

- 类中有成员变量，构造方法，普通块，静态块，启动顺序是什么？

  1. 成员变量，构造方法

     执行顺序：成员变量 > 构造方法

  2. 成员变量，构造方法，静态块

     静态块 > 成员变量 > 构造方法

  3. 成员变量，构造方法，普通块

     成员变量 > 普通块 > 构造方法

  4. 成员变量，构造方法，普通块，静态块

  		静态块 > 成员变量 > 普通块 > 构造方法

- a. 加载类

  1. 为父类静态属性分配内存并赋值 / 执行父类静态代码段 （按代码顺序）
  2. 为子类静态属性分配内存并赋值 / 执行子类静态代码段 （按代码顺序）

  b. 创建对象

  1. 为父类实例属性分配内存并赋值 / 执行父类非静态代码段 （按代码顺序）
  2. 执行父类构造器
  3. 为子类实例属性分配内存并赋值 / 执行子类非静态代码段 （按代码顺序）
  4. 执行子类构造器

#### 3.5抽象

- 抽象：针对现实世界的总结归纳，符合人类的思维习惯，可认为是一种印象

- 抽象三步走;

  1. 找种类：根据现实中的事物进行分类，找出它的种类
  2. 找属性：对象所拥有共同特征
  3. 找方法：对象所具有的共同功能、行为

  需求/设计：到客户那里去找对象  对象 ----》类

  代码：先编写类，再创建对象  类 ----》对象

  设计类：使用类图 分析和设计类；直观，容易理解，便于交流（项目组内交流，一般不对客户进行沟通交流）

#### 3.6final

- final：最终的，一份

  1. 修饰类  ---》最终的类     不能被继承

  2. 修饰变量 ---》常量          不变的数据（成员变量、局部变量、静态变量）

     ```java
     public static final String NAME = "jack";
     ```

  3. 修饰方法 ---》最终的方法  不能被重写 

  4. 修饰形参 ---》相当于常量  实参的值不能被改变 

#### 3.7封装

- 封装：是一种信息隐藏技术，隐藏属性和方法，不希望属性和方法抛头露面

  ​	把属性和方法包裹在对象的内部，通过对象来访问

- 封装的原则;

  1. 所有的属性都i是私有的

  2. 对外提供getter和setter方法（对属性进行读取操作）

     getter()  读取属性操作

     setter()  写属性操作

  3. 属性和方法的权限控制

     public ---  protected  ---  default/friendly  ---  private

- JavaBean组件

### 继承

#### 4.1继承

- 通过extends关键字实现，修饰符是public，则该类在整个项目中可见，若无，则只在当前包中可见；不可以使用private和protected修饰类

- 子类可以从父类中继承;
  1. 继承public和protected修饰的属性和方法，无论子类和父类是否在同一个包里
  2. 继承默认权限修饰符修饰的属性和方法，但子类和父类必须在同一个包中
  3. 无法继承private修饰的属性和方法
  4. 无法继承父类的构造方法

- 方法的重写或方法的覆盖（overriding）
  1. 重写方法和被重写方法必须具有相同的方法名
  2. 重写方法和被重写方法必须具有相同的参数列表
  3. 重写方法的返回值类型必须和被重写方法的返回值类型相同或是其子类
  4. 重写方法不能缩小被重写方法的访问权限

- super代表对当前对象的直接父类对象的默认引用
  1. super必须出现在子类（子类的方法和构造方法）中，而不是其它位置
  2. 可以访问父类的成员，如父类的属性、方法和构造方法
  3. 注意访问权限的限制，如无法通过super访问private成员

- 继承条件下构造方法的调用
  1. 如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其它构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，有没有“super()”语句，效果都是一样的
  2. 如果子类构造方法中通过super显示调用父类的有参构造方法，则将执行父类相应的构造方法，而不执行父类无参的构造方法
  3. 如果子类的构造方法中通过this显式调用自身的其它构造方法，则相应构造方法中应用以上两条规则
  4. 需特别注意的是，如果存在多级继承关系，则在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直执行顶级父类Object类的无参构造方法为止

- 构造方法
  1. 在构造方法中如果this语句或super语句出现，则只能是第一条语句
  2. 在一个构造方法中不允许同时出现使用this和super语句调用构造方法（否则就有两条第一条语句）
  3. 在类方法中不允许出现this或super关键字
  4. 在实例方法中，this和super语句不要求是第一条语句，可以共存

- 继承：

  1. 是一种代码复用技术，减少代码量，提高复用性

  2. 关键字 extends  子类 extends 父类

  3. 关键字 super  代表父类   在子类中使用

     super.属性     super.方法  ===》子类调用父类的属性和方法  （可省略）

     super(参数列表)                 ===》子类调用父类的构造方法  第一行语句（不能省略）

  4. 创建子类的对象之前会先调用父类的构造方法，再调用子类的构造方法

     无论有多少层的父子关系，都是先从最顶层开始……一直到子类

     无论子类是否显式调用父类的构造方法

  5. Override 重写/覆盖

     1. 在父子类中
     2. 方法名相同
     3. 参数列表相同（类型、个数、顺序）
     4. 返回值类型也相同
     5. 权限修饰符也相同

     方法定义部分完全相同，方法的实现可以不同

     好处：重用父类的方法名，隐藏父类的实现

     子类方法前面有@override代表重写方法

  6. Java是单继承体系，有一个超级父类Object

     一个类，只能有一个父类

  7. 向上转型  vs  向下转型

     继承：子类对父类的功能进行扩展

     父类：抽象层次更高，功能较少

     子类：抽象层次更低，功能更完善，更具体

     向上转型：子类指向父类：凡是父类可以使用的地方，子类同样可以（没风险，很安全）

     向下转型：父类指向子类：凡是子类可以使用的地方，父类不一定可以（有风险，不安全）

     子类是一个父类： 子类 is-a  父类

#### 4.2权限修饰符

1. public  公共的，任何人都可以访问
2. protected  受保护的  一般是子类继承父类，访问父类的受保护的属性和方法
3. default/friendly  默认的，友元的；在本包中可以访问
4. private  私有的   只能在本类中访问

| 权限修饰符 | 本类 | 本包 | 子类 | 其它包 |
| :--------: | :--: | :--: | :--: | :----: |
|   public   |  √   |  √   |  √   |   √    |
| protected  |  √   |  √   |  √   |        |
|  default   |  √   |  √   |      |        |
|  private   |  √   |      |      |        |

- 权限修饰符的使用;
  1. 封装的原则、JavaBean组件技术
  2. 工具类中的方法  ---》public
  3. 子类继承父类  ---》protected
  4. 同包中一组功能 ---》default
  5. 保密性要求严格  ---》private

#### 4.3Object

- Java单继承，多实现

- 超级父类Object

- 自定义一个类，默认继承超级父类Object，可以不写

- 继承是一种代码复用技术，提高代码复用性，可维护性

- 不要滥用继承，尽量使用组合

- equals   vs  ==

  - == 既可以比较基本类型，也可以比较引用类型；equals 只能用于引用类型

  - == 基本类型：比较值；引用类型：比较内存地址

  - equals 引用类型：一般比较内容

  - 自定义的类，没有重写equals() +hashCode()

    没有重写：== 和 equals一样，比较的是内存地址

    重写：== 比较内存地址；equals比较内容

    引用类型：对象的名字，数组的名字

  - 凡是new出来的对象，都是在内存中开辟新的空间

- instanceof

  - 对象  instanceof  数据类型（类，接口）

  ```java
  Student s1 = new Student(); //s1引用类型
  
  int[] array  = {1,2,3,4,5}; //array是引用类型
  
  String str = "xxx";  //str是引用类型
  ```

#### 4.4抽象方法

- 抽象类：类是抽象，抽象类比类更抽象：抽象的类
  - 抽象类中有一部分功能没有具体实现（方法），让子类来实现
  - 抽象类中可以有具体实现的方法
- 特征：
  - 使用abstract来修饰类；包含abstract修饰的类是抽象类
  - 抽象类中：具体方法、抽象方法、常量
  - 和抽象方法的关系
    - 包含抽象方法的类，一定是抽象类
    - 抽象类中一定包含抽象方法（不对 ）
    - 抽象类中可以包含抽象方法，具体方法
  - 抽象类不能直接创建对象（不能直接实例化，不能new），只能通过子类继承来访问
  - 抽象类中有构造方法，子类构造方法来调用抽象父类的构造方法
  - 子类继承抽象类，分两种情况;
    - 重写所有的抽象方法：子类具体的类，可以new对象，实例化
    - 不重写/重写部分抽象方法：子类也变成抽象类
  - 作用：类的架构设计，涉及到一些不确定的功能，先搭功能框架
- 抽象方法
  - 使用abstract修饰的方法，方法有定义，无实现；方法结尾一定要加分号；

#### 面试题： 

  1. this  vs  super
     2. Overload  vs  Override、

     Overload的一种特殊形式：

     子类继承父类的方法，和子类现有的方法，构成了重载

### 多态

#### 5.1多态

- 多种行为，多种状态；同一个接口，会有不同的实现

  例子：打印机 ---》打印接口

  ​	黑白打印机 ---》黑白打印

  ​	彩色打印机 ---》彩色打印

  ​	3D打印机 ---》3D立体打印

  分类：

   	1. 参数化多态：重载，也叫超载，过载（Overload）
  	2. 运行时多态：重写，也叫覆盖（Override）

  使用：

  1.  变量  数据类型 尽量是父类（具体类/抽象类），父接口

  2. 方法的形参类型  尽量使用父类（具体类/抽象类），父接口

  3. 方法的返回值类型  尽量使用父类（具体类/抽象类），父接口

  4. 重载 + 重写  

     备注：

     ​	变量：成员变量/局部变量/静态变量

     ​	方法：成员方法/构造方法/静态方法

  作用：

  1. 提高代码的可扩展性（可伸缩性），可维护性
  2. 提高代码的可重用性

  注意事项：

  1. instanceof关键字
  2. 向上转型
  3. 向下转型

### 接口

#### 6.1接口

- 类是抽象的，抽象类比类更抽象；接口是抽象的抽象类；

- 接口是一种标准，规范，一旦定义不轻易改变，代表的是一种承诺和责任

  接口代表具有某种能力，是一种 has - a 的关系

- 使用：

  - 关键字：interface，implements

    interface  定义接口

    implements 实现接口（类来实现接口）

  - 注意事项：

    接口不能直接创建对象

    接口中没有构造方法

    接口中的方法全是抽象方法（JDK1.7以前）

    ​	JDK1.8以后 接口可以提供默认实现（default）

    接口中的方法，权限修饰符都是public,可省略

    ​	接口中的方法，可以使用abstract修饰，可省略

    接口可以使用常量public static final来修饰

    

### 异常
